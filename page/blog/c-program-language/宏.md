# 宏

宏定义是

## 宏的作用机制

### 宏代码

宏是一个 “占座” 工具，他会用文本原封不动的替换掉。如以下代码：

```c
#define I_AM_A_MACRO "%.2f",0.123456f
printf(I_AM_A_MACRO);
```

会被变为：

```c
#define I_AM_A_MACRO "%.2f",0.123456f
printf("%.2f",0.123456f);
```

这个过程在编译之前完成。所以说，宏不可能成为一个真的函数，他在编译之前运行。

这也意味着三个事情：

- 宏函数：相当于代码复制 n 多次，每个宏都将占据程序大小。在代码没有必要写成函数的时，可以使用宏，大型函数不建议使用。

- 宏变量：数据量大时就使用变量。数据量小的时候使用变量和宏没什么区别，如果这个数据不会变，用宏可能会更好看。

- 宏安全：宏参数加括号，宏外面加括号。如：

  ```c
  #define P_A(p, a) (p->a = a)
  #define P_B(p, a) ((p)->a = a)
  
  #define ADD_A(a, b) (a) + (b)
  #define ADD_B(a, b) ((a) + (b))
  ```

  其中 `P_A`、`ADD_A` 是有 bug 的：

  1. 如果使用 `P_A(&p, 13)`，代替后为 `&p->a = 13`，其中`&p->a` 实际顺序是 “`p->a` 的取址”，很明显地址不能赋值。
  2. 如果使用 `ADD_A(1, 2) / 2`，代替后为 `1 + 2 / 2` 导致先算除法，而且还不报错，更加麻烦。

  综上，由于宏直接替换文本，会导致错误。使用时一定要注意宏安全。

### 宏编译

宏还有在编译前做处理的功能。

下面的条件编译宏会在编译之前执行：

```c
#define CASE_1

#ifdef CASE_1
int Func(int a){}
#else
float Func(float a){}
#endif
```

实际编译的代码是

```c
int Func(int a){}
```

条件编译的好处是，在不同的条件下，可以选择性编译不同代码。如果编译两个不同的函数都编译，可能会增加空间。

很明显，条件编译不能在程序运行发挥作用，他在编译时就固定了。